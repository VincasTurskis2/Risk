\graphicspath{ {./Images/} }
\chapter{Implementation}
\section{Game Client Implementation}
\label{gameClientImplementation}
\subsection{Initial Implementation}
\label{initialImplementation}
The initial implementation process for the game client was rather straight-forward. The first thing to be implemented were territories and the ability to click on them and for the game to recognize that. Afterwards, I created the \texttt{GameState} class (which, at the time, included the functionality of both \texttt{GameState} and \texttt{GameMaster}, and made methods in this class be called on click of territories. Almost all interactions the human player has with the game include clicking on the territories. As the implementation continued, I added a few levels of indirection between registering the click and executing the action, such as class \texttt{PlayerActions} and the subclasses of \texttt{Player}, as described in section \ref{codeStructure}. This was followed by the implementation of a simple UI, which provided information for players about whose turn it was and which turn stage they were in, along with a button to end their turn stage (for when a player wanted to stop attacking, or skip their one reinforcing move). This set of features encompasses most actions that a player can take and information that they need. The remaining work was on a main menu/setup page, and various improvements and bug fixes.

A stand-out part of the implementation, and one of the most time-consuming, was drawing the game map. I started out with a picture of the game map taken from the internet as a placeholder, however, it soon became apparent that this will be insufficient, as it made several features nearly impossible to implement - such as changing colors of individual territories, or highlighting them on click/hover. A custom-drawn map was needed, however, I have very little skill and experience in visual art. In the end, I decided to use a reference picture of the game board of Risk, trace every territory, and export each territory as a separate image to be used as a sprite in the Unity game object that represents that territory. I used vector graphics in the drawing application Krita, in order to have each border as a distinct, selectable line. This allowed me to avoid re-drawing a border multiple times and to make sure that, when the separate sprites are re-assembled into the finished map, they would match perfectly.

\subsection{Refactoring}
\label{refactoring}

In the implementation process, I essentially completed the game client before doing any substantial research into possible computer players or Monte Carlo tree search. This turned out to be a mistake, as during that research, it quickly became apparent that certain aspects of the implementation are incompatible with MCTS. The main problem was the structure of \texttt{GameState}, and how interconnected with other classes it was. There were many circular references - \texttt{GameState} kept track of all the players (and the subclasses of \texttt{Player} that represented them), however, each of those classes had a reference to \texttt{GameState} in order to get information about the state, such as who owns which territory. A similar circular reference existed between \texttt{GameState} and \texttt{Territory}, \texttt{Territory} and \texttt{Player}, and several others. This made cloning a game state impossible, but in order to run MCTS, a game state needs to be stored in each node, therefore, cloning a state is essential.

In order to fix the cloning issue, all circular references had to be removed. Some of them could be resolved by moving functionality from one class to another, and removing the reference on one side. However, some references could not be removed this way - for example, \texttt{Territory} needed to keep track of who owns said territory, as this reference was widely used in the code - when checking whether a player action was legal, when determining the display color of a territory, and for updating data in the \texttt{Player} class in methods where the only reference available was the territory. However, the \texttt{Player} class also needed to maintain a list of owned territories, in order to calculate the amount of troops they would receive at the start of each turn, and for computer players to know which territories they can make moves from. In these situations, I replaced one side of the reference with a string (of a player's name, for example), and then added methods to the \texttt{GameState} class to find a reference to an object by going through the list of all objects (all players/all territories/etc.) and finding the one with the matching name. This introduces a problem of efficiency when using these string lookups frequently, however, it at least makes it possible to run an algorithm such as Monte Carlo tree search.

During this process, I separated the \texttt{GameState} into multiple parts in order to make the code more structured and to make swapping between game states easier. The main parts were:
\begin{itemize}
\item \texttt{GameState}, which was partially converted to a facade, containing a reference to other classes which represented different aspects of a game's state, such as the map and the deck of territory cards.
\item \texttt{Map}, a class that keeps track of every territory on the map, as well as providing methods to read/alter the data it contains (such as the aforementioned string lookup)
\item \texttt{GameMaster}, a singleton class which contains a reference to a single game state - the current state being played. This class is used by subclasses of \texttt{PlayerAction} to invoke changes in the current game state without having a reference to that game state. The singleton nature of this class also makes it easy to run MCTS simulation on a state - all one needs to do is save the current state as a reference, clone it, set the clone as the current state in \texttt{GameMaster}, run the simulation, and after the simulation is complete, restore the current state to the previously saved reference. This ensures any actions taken during the simulation will be executed on the cloned, temporary version of the state.
\end{itemize}